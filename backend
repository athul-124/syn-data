# backend/main.py
from fastapi import FastAPI, UploadFile, File, Form
from fastapi.responses import FileResponse, JSONResponse
import pandas as pd
import numpy as np
import os
import uuid
from typing import Optional
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, mean_absolute_error

app = FastAPI()
os.makedirs("uploads", exist_ok=True)
os.makedirs("outputs", exist_ok=True)

def simple_synthetic_tabular(df: pd.DataFrame, n_rows: int):
    synth = pd.DataFrame()
    for col in df.columns:
        series = df[col].dropna()
        if pd.api.types.is_numeric_dtype(series):
            mu = series.mean()
            sigma = series.std(ddof=0) if series.std(ddof=0)>0 else 1.0
            synth[col] = np.random.normal(loc=mu, scale=sigma, size=n_rows)
            # preserve integer type if original was ints
            if pd.api.types.is_integer_dtype(df[col]):
                synth[col] = np.round(synth[col]).astype(int)
        elif pd.api.types.is_datetime64_any_dtype(series):
            mn = series.min().value//10**9
            mx = series.max().value//10**9
            ts = np.random.randint(mn, mx+1, size=n_rows)
            synth[col] = pd.to_datetime(ts, unit='s')
        else:
            # categorical / object
            vals = series.astype(str).value_counts(normalize=True)
            choices = vals.index.tolist()
            probs = vals.values
            synth[col] = np.random.choice(choices, size=n_rows, p=probs)
    return synth

@app.post("/generate")
async def generate(file: UploadFile = File(...), n_rows: int = Form(1000)):
    # save upload
    uid = str(uuid.uuid4())[:8]
    in_path = f"uploads/{uid}_{file.filename}"
    with open(in_path, "wb") as f:
        f.write(await file.read())
    df = pd.read_csv(in_path)
    synth = simple_synthetic_tabular(df, n_rows)
    out_path = f"outputs/synth_{uid}.csv"
    synth.to_csv(out_path, index=False)

    # simple quality summary
    summary = []
    for col in df.columns:
        if pd.api.types.is_numeric_dtype(df[col]):
            real_mu, real_std = float(df[col].mean()), float(df[col].std(ddof=0))
            syn_mu, syn_std = float(synth[col].mean()), float(synth[col].std(ddof=0))
            summary.append({
                "column": col,
                "type": "numeric",
                "real_mean": real_mu, "real_std": real_std,
                "synth_mean": syn_mu, "synth_std": syn_std
            })
        else:
            real_freq = df[col].astype(str).value_counts(normalize=True).to_dict()
            syn_freq = synth[col].astype(str).value_counts(normalize=True).to_dict()
            summary.append({"column": col, "type": "categorical", "real_dist_sample": dict(list(real_freq.items())[:5]), "synth_dist_sample": dict(list(syn_freq.items())[:5])})

    return JSONResponse({"synth_csv": out_path, "summary": summary})

@app.post("/demo-train")
async def demo_train(file: UploadFile = File(...), target: str = Form(...), n_rows: Optional[int] = Form(None)):
    # upload and read
    uid = str(uuid.uuid4())[:8]
    in_path = f"uploads/{uid}_{file.filename}"
    with open(in_path, "wb") as f:
        f.write(await file.read())
    df = pd.read_csv(in_path)
    # quick preprocess: drop NA's, encode categoricals simply
    df = df.dropna(subset=[target])
    X = df.drop(columns=[target])
    y = df[target]
    X_encoded = pd.get_dummies(X, drop_first=True)
    # split real
    X_train_r, X_test_r, y_train_r, y_test_r = train_test_split(X_encoded, y, test_size=0.3, random_state=42)
    model = RandomForestClassifier(n_estimators=50, random_state=42)
    model.fit(X_train_r, y_train_r)
    preds_r = model.predict(X_test_r)
    acc_real = accuracy_score(y_test_r, preds_r)

    # generate synthetic dataset based on original df
    n_synth = n_rows if n_rows else len(df)
    synth = simple_synthetic_tabular(df, n_synth)
    synth = pd.get_dummies(synth.drop(columns=[target], errors='ignore'), drop_first=True)
    # align columns
    synth = synth.reindex(columns=X_encoded.columns, fill_value=0)
    # train on synth then test on real test set
    model2 = RandomForestClassifier(n_estimators=50, random_state=42)
    model2.fit(synth, y_train_r[:len(synth)] if len(y_train_r)>len(synth) else y_train_r)
    preds_s = model2.predict(X_test_r)
    acc_synth = accuracy_score(y_test_r, preds_s)

    return {"acc_real": acc_real, "acc_synth": acc_synth, "delta": acc_synth - acc_real}
